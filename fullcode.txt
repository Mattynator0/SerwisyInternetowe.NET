docker-compose.yml:
<code>
version: "3.9"

services:
  mqtt:
    image: eclipse-mosquitto:2
    container_name: mqtt
    ports:
      - "1883:1883"
    volumes:
      - ./mosquitto.conf:/mosquitto/config/mosquitto.conf

  mongo:
    image: mongo:7
    container_name: mongo
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db

  backend:
    build:
      context: .
      dockerfile: ./MainApplication/Dockerfile
    container_name: backend
    ports:
      - "5000:5000"
    depends_on:
      - mqtt
      - mongo
    environment:
      # ustawienia dla Program.cs (MainApplication)
      - Mqtt__Host=mqtt
      - Mqtt__Port=1883
      - Mongo__ConnectionString=mongodb://mongo:27017
      - Mongo__Database=sensorsDb
      - Mongo__Collection=readings
      - Backend__BaseUrl=http://localhost:5000/

  datagenerator:
    build:
      context: .
      dockerfile: ./DataGenerator/Dockerfile
    container_name: datagenerator
    depends_on:
      - mqtt
    environment:
      # ustawienia dla Program.cs (DataGenerator)
      - Mqtt__Host=mqtt
      - Mqtt__Port=1883

volumes:
  mongo_data:

</code>

mosquitto.conf:
<code>
listener 1883
allow_anonymous true

</code>

DataGenerator\MqttService.cs:
<code>
﻿using MQTTnet;
using System.Text.Json;

namespace DataGenerator;

public class MqttService
{
    private readonly IMqttClient _client;

    public MqttService()
    {
        var factory = new MqttClientFactory();
        _client = factory.CreateMqttClient();
    }

    public async Task ConnectAsync(string brokerHost, int brokerPort)
    {
        var options = new MqttClientOptionsBuilder()
            .WithTcpServer(brokerHost, brokerPort)
            .WithCleanSession()
            .Build();
        
        await _client.ConnectAsync(options);
    }
    
    public IMqttClient GetClient() => _client;
    
    public async Task PublishSensorDataAsync(string topic, object data)
    {
        var jsonData = JsonSerializer.Serialize(data);
        var message = new MqttApplicationMessageBuilder()
            .WithTopic(topic)
            .WithPayload(jsonData)
            .Build();
        
        await _client.PublishAsync(message);
    }
}
</code>

DataGenerator\Program.cs:
<code>
﻿using DataGenerator;

var builder = WebApplication.CreateBuilder(args);
var mqttHost = builder.Configuration["Mqtt:Host"] ?? "mqtt";
var mqttPort = builder.Configuration.GetValue<int?>("Mqtt:Port") ?? 1883;

builder.Services.AddSingleton<MqttService>();
builder.Services.AddControllers();
builder.WebHost.ConfigureKestrel(options =>
{
    options.ListenAnyIP(5001);
});

var app = builder.Build();

var mqttService = app.Services.GetRequiredService<MqttService>();
await mqttService.ConnectAsync(mqttHost, mqttPort);

app.MapControllers();

List<Sensor> sensors = [];

string[] types = ["light", "air-quality", "temperature", "energy"];
foreach (var type in types)
{
    for (var j = 1; j <= 4; j++)
    {
        sensors.Add(new Sensor($"{type}{j}", type, mqttService));
    }
}

foreach (var sensor in sensors)
{
    StartSensorSending(sensor);
}

app.Run();

async void StartSensorSending(Sensor sensor)
{
    Random rnd = new();
    while (true)
    {
        await sensor.PublishDataAsync();
        await Task.Delay(rnd.Next(3000, 8000));
    }
}
</code>

DataGenerator\Sensor.cs:
<code>
﻿namespace DataGenerator;

public class Sensor(string sensorId, string type, MqttService mqttService)
{
    private string SensorId { get; set; } = sensorId;
    private string Type { get; set; } = type;

    private readonly Random _random = new();

    private double GenerateValue()
    {
        return Type switch
        {
            "light" => _random.Next(0, 1000),
            "air-quality" => _random.Next(0, 500),
            "temperature" => _random.Next(-10, 50),
            "energy" => _random.NextDouble() * 10,
            _ => 0
        };
    }

    public async Task PublishDataAsync()
    {
        var data = new
        {
            SensorId,
            Type,
            Value = GenerateValue(),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
        };
        
        var topic = $"sensors/{Type}/{SensorId}";
        
        await mqttService.PublishSensorDataAsync(topic, data);
    }
}
</code>

DataGenerator\SensorsController.cs:
<code>
﻿namespace DataGenerator;

using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api")]
public class SensorsController(MqttService mqttService) : ControllerBase
{
    [HttpPost("manual")]
    public async Task<IActionResult> SendManualData([FromBody] SensorData input)
    {
        await mqttService.PublishSensorDataAsync($"sensors/{input.Type}", input);
        return Ok("Manual sensor data sent.");
    }
}

public class SensorData
{
    public string SensorId { get; set; }
    public string Type { get; set; }
    public double Value { get; set; }
    public long Timestamp { get; set; }
}
</code>

DataGenerator\Properties\launchSettings.json:
<code>
{
  "profiles": {
    "DataGenerator": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:65232;http://localhost:65233"
    }
  }
}
</code>

MainApplication\MqttMongoService.cs:
<code>
﻿using System.Buffers;

namespace MainApplication;

using MQTTnet;
using MongoDB.Driver;
using System.Text;
using System.Text.Json;


public class MqttMongoService
{
    private readonly IMqttClient _mqttClient;
    private readonly MqttClientOptions _options;

    public MqttMongoService(string mqttHost, int mqttPort, string mongoConnectionString, string mongoDbName, string mongoCollectionName)
    {
        var factory = new MqttClientFactory();
        _mqttClient = factory.CreateMqttClient();

        var client = new MongoClient(mongoConnectionString);
        var database = client.GetDatabase(mongoDbName);
        var collection = database.GetCollection<SensorData>(mongoCollectionName);

        _options = new MqttClientOptionsBuilder()
            .WithTcpServer(mqttHost, mqttPort)
            .WithCleanSession()
            .Build();

        _mqttClient.ConnectedAsync += async e =>
        {
            Console.WriteLine("Connected to MQTT broker");
            var subscribeOptions = new MqttClientSubscribeOptionsBuilder()
                .WithTopicFilter(f =>
                {
                    f.WithTopic("sensors/#")
                        .WithAtMostOnceQoS();
                })
                .Build();
            
            await _mqttClient.SubscribeAsync(subscribeOptions);

            Console.WriteLine("Subscribed to sensors/#");
        };
        _mqttClient.ApplicationMessageReceivedAsync += async e =>
        {
            try
            {
                var payload = Encoding.UTF8.GetString(e.ApplicationMessage.Payload.ToArray());

                var data = JsonSerializer.Deserialize<SensorData>(payload);

                if (data != null)
                {
                    await collection.InsertOneAsync(data);
                    Console.WriteLine($"Saved sensor data for SensorId={data.SensorId}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
            }
        };
    }
    
    public async Task StartAsync()
    {
        await _mqttClient.ConnectAsync(_options);
    }
}

</code>

MainApplication\Program.cs:
<code>
﻿using MainApplication;
using MongoDB.Driver;

var builder = WebApplication.CreateBuilder(args);

var mqttHost = builder.Configuration["Mqtt:Host"] ?? "mqtt";
var mqttPort = builder.Configuration.GetValue<int?>("Mqtt:Port") ?? 1883;

var mongoConnectionString = builder.Configuration["Mongo:ConnectionString"] ?? "mongodb://mongo:27017";
var mongoDbName = builder.Configuration["Mongo:Database"] ?? "sensorsDb";
var mongoCollectionName = builder.Configuration["Mongo:Collection"] ?? "readings";

// MQTT -> Mongo
builder.Services.AddSingleton<MqttMongoService>(_ => new MqttMongoService(
    mqttHost: mqttHost,
    mqttPort: mqttPort,
    mongoConnectionString: mongoConnectionString,
    mongoDbName: mongoDbName,
    mongoCollectionName: mongoCollectionName
));

// HttpClient do wywoływania własnego API z Razor Pages
builder.Services.AddHttpClient("ApiClient", client =>
{
    // domyślnie łączy się z tym samym backendem
    var baseUrl = builder.Configuration["Backend:BaseUrl"] ?? "http://localhost:5000/";
    client.BaseAddress = new Uri(baseUrl);
});

// Serwis do czytania z Mongo
builder.Services.AddSingleton<ISensorDataService>(sp =>
{
    var mongoClient = new MongoClient(mongoConnectionString);
    var database = mongoClient.GetDatabase(mongoDbName);
    var collection = database.GetCollection<SensorData>(mongoCollectionName);
    return new SensorDataService(collection);
});

builder.Services.AddControllers();
builder.Services.AddRazorPages();

// ważne w Dockerze – nasłuch na wszystkich interfejsach
builder.WebHost.UseUrls("http://0.0.0.0:5000");

var app = builder.Build();

var mqttService = app.Services.GetRequiredService<MqttMongoService>();
await mqttService.StartAsync();

app.UseRouting();

app.MapRazorPages();
app.MapControllers();

app.Run();
</code>

MainApplication\SensorData.cs:
<code>
﻿namespace MainApplication;
using MongoDB.Bson;

public class SensorData
{
    public ObjectId Id { get; set; }
    public string SensorId { get; set; }
    public string Type { get; set; }
    public double Value { get; set; }
    public long Timestamp { get; set; }
}
</code>

MainApplication\SensorDataController.cs:
<code>
﻿using System.Globalization;
using System.Text;

namespace MainApplication;

using Microsoft.AspNetCore.Mvc;

[Route("api/[controller]")]
[ApiController]
public class SensorDataController : ControllerBase
{
    private readonly ISensorDataService _sensorDataService;

    public SensorDataController(ISensorDataService sensorDataService)
    {
        _sensorDataService = sensorDataService;
    }
    [HttpGet("data")]
    public async Task<IActionResult> GetTableData(
        [FromQuery] string type,
        [FromQuery] string sortColumn = "Timestamp",
        [FromQuery] string sortDirection = "desc",
        [FromQuery] string filterSensorId = null,
        [FromQuery] string filterTimestampBefore = null,
        [FromQuery] string filterTimestampAfter = null)
    {
        var data = await GetData(type, sortColumn, sortDirection, filterSensorId, filterTimestampBefore, filterTimestampAfter);

        return Ok(data);
    }

    [HttpGet("export")]
    public async Task<IActionResult> ExportData(
        [FromQuery] string type,
        [FromQuery] string sortColumn = "timestamp",
        [FromQuery] string sortDirection = "desc",
        [FromQuery] string format = "csv",
        [FromQuery] string filterSensorId = null,
        [FromQuery] string filterTimestampBefore = null,
        [FromQuery] string filterTimestampAfter = null)
    {
        var data = await GetData(type, sortColumn, sortDirection, filterSensorId, filterTimestampBefore, filterTimestampAfter);

        if (!format.Equals("csv"))
            return Ok(data);

        var csvBuilder = new StringBuilder();
        using var writer = new StringWriter(csvBuilder);
        using var csv = new CsvHelper.CsvWriter(writer, CultureInfo.InvariantCulture);
        csv.WriteRecords(data);
        return File(Encoding.UTF8.GetBytes(csvBuilder.ToString()), "text/csv", "data.csv");
    }

    private async Task<List<SensorData>> GetData(
        string type,
        string sortColumn,
        string sortDirection,
        string filterSensorId,
        string filterTimestampBefore,
        string filterTimestampAfter)
    {
        var data = await _sensorDataService.GetByTypeAsync(type);
        
        if (!string.IsNullOrEmpty(filterSensorId))
            data = data.Where(d => d.SensorId.Contains(filterSensorId, StringComparison.OrdinalIgnoreCase)).ToList();
        if (!string.IsNullOrEmpty(filterTimestampBefore) && long.TryParse(filterTimestampBefore, out var dtb))
            data = data.Where(d => d.Timestamp < dtb).ToList();
        if (!string.IsNullOrEmpty(filterTimestampAfter) && long.TryParse(filterTimestampAfter, out var dta))
            data = data.Where(d => d.Timestamp > dta).ToList();
        
        Func<SensorData, object> keySelector = sortColumn.ToLower() switch
        {
            "sensorid" => x => x.SensorId,
            "type" => x => x.Type,
            "value" => x => x.Value,
            _ => x => x.Timestamp
        };
        data = sortDirection.Equals("desc")
            ? data.OrderByDescending(keySelector).ToList()
            : data.OrderBy(keySelector).ToList();
        return data;
    }
    [HttpGet("dashboard")]
    public async Task<ActionResult<List<SensorDashboardDto>>> GetDashboard()
    {
        var data = await _sensorDataService.GetDashboardAsync();
        return Ok(data);
    }
}
</code>

MainApplication\SensorDataService.cs:
<code>
﻿namespace MainApplication;

using MongoDB.Driver;
using System.Collections.Generic;
using System.Threading.Tasks;

public interface ISensorDataService
{
    Task<List<SensorData>> GetByTypeAsync(string type);
    Task<List<SensorDashboardDto>> GetDashboardAsync();
}

public class SensorDataService : ISensorDataService
{
    private readonly IMongoCollection<SensorData> _collection;

    public SensorDataService(IMongoCollection<SensorData> collection)
    {
        _collection = collection;
    }

    public async Task<List<SensorData>> GetByTypeAsync(string type)
    {
        if (string.IsNullOrEmpty(type))
            return await _collection.Find(x => true).ToListAsync();
            
        var filter = Builders<SensorData>.Filter.Eq(s => s.Type, type);
        return await _collection.Find(filter).ToListAsync();
    }

    public async Task<List<SensorDashboardDto>> GetDashboardAsync()
    {
        var result = new List<SensorDashboardDto>();

        var sensorIds = await _collection.Distinct<string>("SensorId", FilterDefinition<SensorData>.Empty).ToListAsync();

        foreach (var sensorId in sensorIds)
        {
            var filter = Builders<SensorData>.Filter.Eq(s => s.SensorId, sensorId);
            var sort = Builders<SensorData>.Sort.Descending(s => s.Timestamp);

            // ostatnie 100 pomiarów
            var last100 = await _collection
                .Find(filter)
                .Sort(sort)
                .Limit(100)
                .ToListAsync();

            if (!last100.Any())
                continue;

            var latest = last100.First();

            var dto = new SensorDashboardDto
            {
                SensorId = sensorId,
                Type = latest.Type,
                LastValue = latest.Value,
                LastTimestamp = latest.Timestamp,
                AverageLast100 = last100.Average(x => x.Value)
            };

            result.Add(dto);
        }

        return result;
    }
}

</code>

MainApplication\Models\SensorDashboardDto.cs:
<code>
﻿namespace MainApplication
{
    public class SensorDashboardDto
    {
        public string SensorId { get; set; } = default!;
        public string Type { get; set; } = default!;
        public double LastValue { get; set; }
        public long LastTimestamp { get; set; }
        public double AverageLast100 { get; set; }
    }
}

</code>

MainApplication\Pages\Index.cshtml.cs:
<code>
﻿using Microsoft.AspNetCore.Mvc.RazorPages;

namespace MainApplication;

public class Index : PageModel
{
    public void OnGet()
    {
        
    }
}
</code>

MainApplication\Pages\SensorData.cshtml.cs:
<code>
﻿using Microsoft.AspNetCore.Mvc.RazorPages;

namespace MainApplication.Pages;

public class SensorDataModel(IHttpClientFactory httpClientFactory) : PageModel
{
    public List<SensorData> SensorDataList { get; set; }
    public string FilterType { get; set; }

    public async Task OnGetAsync(string type)
    {
        Console.WriteLine(type);
        FilterType = type;

        var client = httpClientFactory.CreateClient("ApiClient");
        SensorDataList = await client.GetFromJsonAsync<List<SensorData>>($"api/SensorData/data?type={type}");
    }
}

</code>

MainApplication\Properties\launchSettings.json:
<code>
{
  "profiles": {
    "MainApplication": {
      "commandName": "Project",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "https://localhost:65230;http://localhost:65231"
    }
  }
}
</code>

